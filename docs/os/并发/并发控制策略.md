# 并发控制策略


## 一、悲观并发控制

总是假设最坏的情况。也就是说，每次去访问共享资源的时候都认为别人会修改，所以每次在进入临界区的时候都会加锁，这样别人想访问这个共享资源就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把共享资源使用权转让给其他线程）。


### 适用场景

悲观并发控制适用于写比较多的情况下。


### 实现

- 锁机制
    - 自旋锁
    - 互斥锁



## 二、乐观并发控制

总是假设最好的情况。也就是说，即使在并发环境下，也认为各个线程对共享资源的操作是同步执行（虽然实际不是），不需要加锁控制。

当前线程先获取一份共享数据的拷贝 `old`；然后在执行完逻辑之后，尝试将修改后的值 `new` 写入共享数据的实际存储空间；但是在写入之前，先检查一下共享数据的值还是不是 `old`。如果是，那就说明共享数据没有被修改，可以将共享数据的值更新为 `new`；如果不是，那就说明共享数据被其他线程修改过，那么就要采取其他补偿措施（不进行修改或者循环重试）。

通俗地说，就是先执行逻辑，执行完之后就尝试写入，如果没有其他线程争用共享资源，那操作成功了；如果共享数据有争用，产生了冲突，那就再采取其他的补偿措施。


### 过程

从上面的描述来看，乐观并发控制的过程可以分为 5 个阶段：

1. 读取阶段：当前线程读取共享数据，生成一份拷贝。
2. 修改阶段：执行代码逻辑，得到修改；执行完之后，准备写入数据。
3. 检查阶段：进入写入阶段前先进行检查真正的共享数据有没有被修改，也就是判断真正的共享数据的值和当前线程的拷贝值是否一样。
4. 写入阶段：如果真正的共享数据没有被修改，就将修改值写入；如果被修改了，进入补偿阶段。
5. 补偿阶段
    - 循环重试
    - 不进行修改


### 适用场景

乐观并发控制认为竞争很少出现，当竞争发生时由调用方重试或者其他处理方式；由于没有加锁带来的较高开销和加锁中的临界区限制，这种无锁（lock-free）机制相比加锁具有更高的扩展性。

乐观并发控制适用于多读场景，也就是冲突真的很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。


### 实现

- 版本号机制
- CAS
