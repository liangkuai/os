# 乐观并发控制

总是假设最好的情况。

也就是说，即使在并发环境下，也认为各个线程对共享资源的操作是同步执行（虽然实际不是），不需要加锁控制。

当前线程先获取一份共享数据的拷贝 `old`；然后执行逻辑，执行完之后，共享数据的值被修改成了 `new`；然后尝试把修改后的值 `new` 写入共享数据的实际存储空间；但是在写入之前，先检查一下共享数据的值还是不是 `old`；如果是，那就说明共享数据没有被修改，可以将共享数据的值更新为 `new`；如果不是，那就说明共享数据被其他线程修改过，那么就要采取其他补偿措施（不进行修改或者循环重试）。

通俗地说，就是先执行逻辑，执行完之后就尝试写入，如果没有其他线程竞争共享资源，那操作成功了；如果共享数据有竞争，产生了冲突，那就再采取其他的补偿措施。


### 1. 过程

从上面的描述来看，乐观并发控制的过程可以分为 5 个阶段：

1. 读取阶段：当前线程读取共享数据，生成一份拷贝。
2. 修改阶段：执行代码逻辑，得到共享数据的修改值；执行完之后，准备写入数据。
3. 检查阶段：进入写入阶段前先进行检查，真正的共享数据有没有被修改，也就是判断真正的共享数据的值和当前线程的拷贝值是否一样。
4. 写入阶段：如果真正的共享数据没有被修改，就将修改值写入；如果被修改了，进入补偿阶段。
5. 补偿阶段
    - 循环重试
    - 不进行修改


### 2. 适用场景

乐观并发控制认为竞争很少出现，当竞争发生时由调用方重试或者其他处理方式；由于没有加锁带来的较高开销和加锁中的临界区限制，这种无锁（lock-free）机制相比加锁具有更高的扩展性。

乐观并发控制适用于读多写少的场景。也就是冲突很少发生的时候，这样可以省去锁的开销，加大了系统的整个吞吐量。


### 3. 实现

- [版本号机制](./版本号机制.md)
- [CAS](./CAS.md)
