# 悲观并发控制

总是假设最坏的情况。

也就是说，每次去访问共享资源的时候都认为其他线程会修改，所以每次在进入临界区的时候都会加锁，这样其他线程想访问这个共享资源就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其他线程阻塞，用完后再把共享资源使用权转让给其他线程）。


### 1. 适用场景

悲观并发控制适用于写多读少的场景。这样可以避免频繁失败和重试影响性能。


### 2. 实现

- [锁机制](./锁.md)
    - 自旋锁
    - 互斥锁